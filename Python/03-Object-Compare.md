# 对象比较效率分析

翻了一下网页，没什么讲这方面的资料。因为目标对象是16进制的字符串，因此做了一点简单的测试来检测各种对象比较的效率。其他的对象一般也会有类似的结果。

## 源码

``` python
import time

a = 'f2c298be00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000035454f53365878737147776a78546f4765424e68647a463367344a387067466a3858654c4d5a6566696277426d4273663447613358530000000000000000000000'
b = 'f2c298be00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000035454f53365878737147776a78546f4765424e68647a463367344a387067466a3858654c4d5a6566696277426d4273663447613358530000000000000000000000'
z1 = 15
z2 = 37
z3 = 52
z4 = 88
std = [a[:z1], a[z2:z3], a[z4:]]

# case 1.0
time_a1 = time.time()

for i in range(100000):
    if b[:z1] == std[0]:
        if b[z2:z3] == std[1]:
            if b[z4:] == std[2]:
                continue

time_a2 = time.time()
print(time_a2 - time_a1)

# case 1.1
time_a1 = time.time()

for i in range(100000):
    if b.startswith(std[0], 0):
        if b.startswith(std[1], z2):
            if b.startswith(std[2], z4):
                continue

time_a2 = time.time()
print(time_a2 - time_a1)

# case 2.0
time_a1 = time.time()

for i in range(100000):
    if a == b:
        continue

time_a2 = time.time()
print(time_a2 - time_a1)

# case 2.0.1
ccc = 'f2c298be00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000035454f53365878737147776a78546f4765424e68647a463367344a387067466a3858654c4d5a6566696277426d4273663447613358530000000000000000000001'
time_a1 = time.time()

for i in range(100000):
    if a == ccc:
        continue

time_a2 = time.time()
print(time_a2 - time_a1)

# case 2.1
l = len(a)
time_a1 = time.time()

for i in range(100000):
    for j in range(l):
        if a[j] == b[j]:
            continue

time_a2 = time.time()
print(time_a2 - time_a1)

# case 2.2
time_a1 = time.time()

for i in range(100000):
    y1 = int(a, 16)
    y2 = int(b, 16)
    if y1 == y2:
        continue

time_a2 = time.time()
print(time_a2 - time_a1)

# find the explaination
print(id(a))
print(id(b))
print(id(b[:z1]))
print(id(std[0]))
print(b[:z1])
print(std[0])
print(b[:z1] == std[0])
```

## 分析

先给出各个case的意义：

* case 1: 假设两个对象中只有连续的几个部分相同。
* case 1.0: 用切片的方式取出相同的部分。
* case 1.1: 用字符串自带的函数startswith。
* case 2: 比较两个对象是否完全相同。
* case 2.0: 直接比较相同。
* case 2.1: 循环比较各个字符。
* case 2.2: 转换成16进制数后再比较相同。

结果（秒）：

* case 1.0: 0.04088926315307617
* case 1.1: 0.052872657775878906
* case 2.0: 0.006975412368774414
* case 2.1: 3.136490821838379
* case 2.2: 0.132460355758667

分析：

1. 可以看出循环是非常费时的操作，比较相同与否时最好避免循环比较。
2. 切片与startswith的时间开销接近。
3. 为两个对象赋值完后直接比较速度最快。
4. 转换成16进制所花费的时间相比于循环操作更快，尤其是在16进制字符串很长的时候。

猜测：

1. 首先不难得出循环操作的时间复杂度是$O(NL)$，其中$N$是大循环的数量，$L$是对象的长度。
2. case 2.0最快的原因应该是两者的指向是相同的，即对应相同的内存地址，因此可以直接判断相等。当内存地址不同时，速度会稍微慢一点，但实际上也很快（参见case 2.0.1）。
3. case 1和case 2.2的时间稍长，应该是来自于额外的时间开销，即切片、函数以及类型转换。
4. 可以肯定的是直接比较是不涉及循环比较的，即不存在小循环。可能用到了哈希或者字节码操作等方式，具体还不太清楚。

## 额外测试

``` python
import time

str1 = "0xf2c298be00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000035454f533676504b694a55666f3471356768354d73386e594d78754e36547959716868666e6f555142597735644c6a7948715a6475450000000000000000000000"
str2 = "0xf2c298be00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000035454f533676505648476a3546705274784d6f566d713555467579625879667276766935434172444c6451794b366b637956747032520000000000000000000000"
str3 = "0xf2c298be00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000035454f533676505a59636e635973467756794d754d6f48376462665355776564754862707031336b793233714b6a55746172444a71460000000000000000000000"
str4 = "0xf2c298be00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000035454f5336765063673762447938624a3379504a3570616d506b44314451503175764534694c436f72514c45376934664d79435379480000000000000000000000"

l = [str1, str2, str3, str4]

# case 1
time_a1 = time.time()

for i in range(100000):
    str_l = len(str1)
    l_l = len(l)
    mask = [1] * str_l
    m_std = l[0]
    for j in range(str_l):
        for k in range(1, l_l):
            if not mask[j]:
                break
            mask[j] = (l[k][j] == m_std[j])

time_a2 = time.time()
print(time_a2 - time_a1)
print(mask)

# case 2
time_a1 = time.time()

for i in range(100000):
    zzz = list(map(lambda x: int(x, 16), l))
    m_std = zzz[0]
    mask = 0
    for j in range(1, len(zzz)):
        mask |= m_std ^ zzz[j]
    cur_l = len(str1)
    real_mask = [True] * cur_l
    for j in range(cur_l):
        real_mask[cur_l - j - 1] = False if (mask & 0xf) else True
        mask >>= 4
        if mask == 0:
            break

time_a2 = time.time()
print(time_a2 - time_a1)
print(real_mask)
```

测试结果：

* case 1: 18.650736331939697
* case 2: 3.573246955871582

这里是6倍的差距。估计是数字太大的原因，当将对象换成更短的：

``` python
str1 = "0xa9059cbb00000000000000000000000037b0415b7259f43c43d2af7136657b161432cfdb00000000000000000000000000000000000000000000000000000000792baa88"
str2 = "0xa9059cbb00000000000000000000000037b0415b7259f43c43d2af7136657b161432cfdb00000000000000000000000000000000000000000000000000000001d0ea8e00"
str3 = "0xa9059cbb00000000000000000000000037b0415b7259f43c43d2af7136657b161432cfdb000000000000000000000000000000000000000000000000000000021c6f70c0"
str4 = "0xa9059cbb00000000000000000000000037b0415b7259f43c43d2af7136657b161432cfdb0000000000000000000000000000000000000000000000000000000baf701b00"
```

结果是：

* case 1: 10.485540866851807
* case 2: 0.6100249290466309

有10倍多的差距，不过感觉数量级还是一样的...
