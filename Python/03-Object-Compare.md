# 对象比较效率分析

翻了一下网页，没什么讲这方面的资料。因为目标对象是16进制的字符串，因此做了一点简单的测试来检测各种对象比较的效率。其他的对象一般也会有类似的结果。

## 源码

``` python
import time

a = 'f2c298be00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000035454f53365878737147776a78546f4765424e68647a463367344a387067466a3858654c4d5a6566696277426d4273663447613358530000000000000000000000'
b = 'f2c298be00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000035454f53365878737147776a78546f4765424e68647a463367344a387067466a3858654c4d5a6566696277426d4273663447613358530000000000000000000000'
z1 = 15
z2 = 37
z3 = 52
z4 = 88
std = [a[:z1], a[z2:z3], a[z4:]]

# case 1.0
time_a1 = time.time()

for i in range(100000):
    if b[:z1] == std[0]:
        if b[z2:z3] == std[1]:
            if b[z4:] == std[2]:
                continue

time_a2 = time.time()
print(time_a2 - time_a1)

# case 1.1
time_a1 = time.time()

for i in range(100000):
    if b.startswith(std[0], 0):
        if b.startswith(std[1], z2):
            if b.startswith(std[2], z4):
                continue

time_a2 = time.time()
print(time_a2 - time_a1)

# case 2.0
time_a1 = time.time()

for i in range(100000):
    if a == b:
        continue

time_a2 = time.time()
print(time_a2 - time_a1)

# case 2.0.1
ccc = 'f2c298be00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000035454f53365878737147776a78546f4765424e68647a463367344a387067466a3858654c4d5a6566696277426d4273663447613358530000000000000000000001'
time_a1 = time.time()

for i in range(100000):
    if a == ccc:
        continue

time_a2 = time.time()
print(time_a2 - time_a1)

# case 2.1
l = len(a)
time_a1 = time.time()

for i in range(100000):
    for j in range(l):
        if a[j] == b[j]:
            continue

time_a2 = time.time()
print(time_a2 - time_a1)

# case 2.2
time_a1 = time.time()

for i in range(100000):
    y1 = int(a, 16)
    y2 = int(b, 16)
    if y1 == y2:
        continue

time_a2 = time.time()
print(time_a2 - time_a1)

# find the explaination
print(id(a))
print(id(b))
print(id(b[:z1]))
print(id(std[0]))
print(b[:z1])
print(std[0])
print(b[:z1] == std[0])
```

## 分析

先给出各个case的意义：

* case 1: 假设两个对象中只有连续的几个部分相同。
* case 1.0: 用切片的方式取出相同的部分。
* case 1.1: 用字符串自带的函数startswith。
* case 2: 比较两个对象是否完全相同。
* case 2.0: 直接比较相同。
* case 2.1: 循环比较各个字符。
* case 2.2: 转换成16进制数后再比较相同。

结果（秒）：

* case 1.0: 0.04088926315307617
* case 1.1: 0.052872657775878906
* case 2.0: 0.006975412368774414
* case 2.1: 3.136490821838379
* case 2.2: 0.132460355758667

分析：

1. 可以看出循环是非常费时的操作，比较相同与否时最好避免循环比较。
2. 切片与startswith的时间开销接近。
3. 为两个对象赋值完后直接比较速度最快。
4. 转换成16进制所花费的时间相比于循环操作更快，尤其是在16进制字符串很长的时候。

猜测：

1. 首先不难得出循环操作的时间复杂度是$O(NL)$，其中$N$是大循环的数量，$L$是对象的长度。
2. case 2.0最快的原因应该是两者的指向是相同的，即对应相同的内存地址，因此可以直接判断相等。当内存地址不同时，速度会稍微慢一点，但实际上也很快（参见case 2.0.1）。
3. case 1和case 2.2的时间稍长，应该是来自于额外的时间开销，即切片、函数以及类型转换。
4. 可以肯定的是直接比较是不涉及循环比较的，即不存在小循环。可能用到了哈希或者字节码操作等方式，具体还不太清楚。